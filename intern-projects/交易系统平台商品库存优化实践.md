# 1. 背景介绍
1. 下单核心流程：
```
用户下单操作
    |
同步查询库存 -- 实时库存服务
    |
  (判断)
 库存充足？ -(否)- 下单失败
    |
   (是)
    |
 下单成功 --(发MQ异步减库存)--> 实时库存服务 -> cellar集群
```
2. 商品交易：超卖、少卖情况
	1. 超卖：在同步查询库存时都通过，但在异步减库存时，发现不够
	2. 少卖：超卖之后，取消订单，导致下单库存够的用户也没买到
# 2. 问题分析
1. 异步减库存：导致订单服务无法感知减库存成功与否
	1. 改为同步减库存
2. 库存服务调用cellar减库存：网络异常导致订单服务调用库存服务异常，重试导致重复减库存，出现超卖
	1. 服务层调研方案
3. cellar集群：允许库存减为负数，导致超卖
	1. 更换存储引擎
# 3. 方案调研
1. 方案一：基于mysql存储，mysql行锁防止库存减为负数：`update tableName set stock = stock -${decrStock} where sku_id = ${skuId} and stock >= ${decrStock}`
	1. 优点：实现简单
	2. 缺点：无法解决**同一订单重复减库存**问题
2. 方案二：基于redis存储，利用`setNx`分布式锁保证库存操作幂等性，同时redis事务机制(`lua`)保证`setNx`和库存操作的原子性
	1. 优点：实现简单，性能高
	2. 缺点：对于**同一订单&同一sku退货**的问题较难解决
3. 方案三：基于AliSQL存储，AliSQL有请求排队、事务批量提交功能
	1. 优点：相比mysql性能更高
	2. 缺点：运维难度高
4. 方案四：基于mysql存储，行锁防止库存减为负数：`update tableName set stock = stock -${decrStock} where sku_id = ${skuId} and stock >= ${decrStock}`；同步记录库存变更流水，流水表唯一键`订单id + skuid`，保证减库存幂等性；多表事务保证原子性
	1. 优点：增/减库存幂等性，订单和库存数据一致性
	2. 缺点：需同步记录减库存流水和多表事务，影响性能
# 4. 方案选型
1. 选定方案四
![[Pasted image 20240903161459.png]]
2. 流程：
	1. 同步减库存，异步记录流水
	2. 流水表唯一键（`订单id + sku id + seq`）保证幂等性
	3. 库存校验保证流水表和库存DB数据最终一致性
	4. 