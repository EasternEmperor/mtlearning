# 1. 剖析`ArrayList`
1. `ArrayList`是一个泛型容器，内部是一个`Object[]`数组来保存元素
## 1.2 基本原理
1. 解析`add`和`remove`方法
	1. `add`首先确保数组大小能装下元素`newCap`，如果不能，则先扩容到`oldSize`的1.5倍，如果仍小于需求的容量，则扩容至`newCap`
		1. 其中扩容前执行`modCount++`
	2. `remove`首先计算要移动的元素个数，将后面的元素前移
		2. 移动元素前执行`modCount++`
## 1.3 迭代
1. `foreach`代码实际上会转换为迭代器执行：
```java
Iterator<Integer> it = intList.iterator();
while (it.hasNext()) {
	// ...
}
```
2. 迭代器接口：`ArrayList`实现了`Iterable`接口
3. 迭代器陷阱：
	1. 在`foreach`过程中这样删除元素报错：`list.remove(i)`
	2. 可以通过迭代器删除：`it.next(); it.remove()`
### 1.3.4 迭代器实现原理
1. `ArrayList`中`iterator()`方法如下：
```java
public Iterator<E> iterator() {
	return new Itr();
}
```
2. `Itr`是内部类，实现了`Iterator`接口
```java
private class Itr implements Iterator<E> {  
    int cursor;       // index of next element to return  
    int lastRet = -1; // index of last element returned; -1 if no such  
    int expectedModCount = modCount;
    // ...
}
```
3. `expectedModCount`赋值为`modCount`，因为每次`add`和`remove`都会增加`modCount`，由此迭代器可判断列表结构是否发生变化
4. 迭代器好处：
	1. 语法简洁
	2. 关注点分离：将数据组织方式和数据遍历方式分离，遍历时无需关注数据的组织方式

# 2. 剖析`LinkedList`
## 2.1 用法
1. 实现了`List`接口和队列接口`Dueue`，而`Dueue`实现了`Queue`接口
	1. 在尾部添加元素`add`、`offer`
	2. 在头部添加元素`push`
	3. 查看头部元素`element`、`peek`
	4. 删除头部元素`remove`、`poll`
	5. 删除尾部元素`pop`
## 2.2 实现原理
1. 内部组成：`LinkedList`内部实现为双向链表，有一个内部类`Node`
```java
private static class Node<E> {
	E item;
	Node<E> prev;
	Node<E> next;
	Node(Node<E> prev, E element, Node<E> next) {
		this.item = element;
		this.next = next;
		this.prev = prev;
	}
}

// LinkedList内部组成有如下三个实例变量
transient int size = 0;
transient Node<E> first;
transient Node<E> last;
```