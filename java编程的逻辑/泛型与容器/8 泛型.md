# 1. 基本概念和原理
## 1.1 一个简单泛型类
1. 一个泛型类如下：
```java
public class Pair<T> {
	T first;
	T second;
	public Pair(T first, T second) {
		this.first = first;
		this.second = second;
	}
	public T getFirst() {
		return first;
	}
	public T getSecond() {
		return second;
	}
}
```
2. T表示类型参数
3. 对于泛型类，`Java`编译器会将泛型代码转换为普通的非泛型代码，将参数类型T擦除，**替换**为`Object`，插入必要的**强制类型转换**
	- 所以上面的泛型类在编译后可表示为：
```java
public class Pair {
	Object first;
	Object second;
	public Pair(Object first, Object second) {
		this.first = first;
		this.second = second;
	}
	public Object getFirst() {
		return first;
	}
	public Object getSecond() {
		return second;
	}
}
```
## 1.2 容器类
1. 泛型类最常见是用于容器类，管理多项数据，如数组、map等
## 1.3 泛型方法
1. 如下，表示类型参数为T，放在返回值前
```java
public static <T> int indexOf(T[] arr, T elm) {
	for (int i=0; i < arr.length; i++) {
		if (arr[i].equals(elm)) {
			return i;
		}
	}
	return -1;
}
```
2. 调用时不需要特意指定类型参数的实际类型，编译器能自动推断，调用`indexOf`：
```java
Integer[] i = new Integer[]{1, 2, 3};
indexOf(i, 1);
```
## 1.4 泛型接口
1. 泛型接口在实现接口时需要指定具体的类型
## 1.5 类型参数的限定
1. `Java`支持限定参数的一个上界，即参数必须为给定的上界类型或其子类，通过`extends`关键字实现
2. 上界为某个具体类：限定为边界后，类型擦除不转换为`Object`而是边界类型
```java
public class Pair<U extends Number, V extends Number>
```
3. 上界为某个接口：
```java
// 递归类型限制，说明T必须实现Comparable接口，并且和同类型元素比较
public static <T extends Comparable<T>> T max(T[] arr)
```
4. 上界为其他类型参数：注意参数类型不能用`<T extends E>`这种写法，`<T extends E>`只能用于类或方法的泛型声明处使用
```java
// 举例
public void addAll(DynamicArray<E> c) { 
	// addAll逻辑...
}
DynamicArray<Number> list = new DynamicArray<>();
DynamicArray<Integer> ints = new DynamicArray<>(){1, 2, 3};
// 以下将报错！！因为Integer和Number并非同类
list.addAll(ints);

// 可用方法
public <T extends E> void addAll(DynamicArray<E> c) { 
	// addAll逻辑...
}
DynamicArray<Number> list = new DynamicArray<>();
DynamicArray<Integer> ints = new DynamicArray<>(){1, 2, 3};
// 以下就不报错
list.addAll(ints);
```

# 2. 解析通配符
## 2.1 更简洁的参数类型限定
1. 更换为通配符形式：
```java
public void addAll(DynamicArray<? extends E> c) {
	// addAll逻辑...
}
```
2. `<T extends E>`和`<? extends E>`的区别：
	1. `<T extends E>`用于**定义**类型参数，可放在泛型类定义中类名后面、泛型方法返回值前面
	2. `<? extends E>`用于**实例化**类型参数，在函数参数中表示未知类型的参数
## 2.2 理解通配符
1. 无限定通配符：
```java
// 从未知类型容器中查找数据下标
public static int indexOf(DynamicArray<?> arr, Object elm){
	//...
}
```
2. 通配符的限制：只能读，不能写
	1. 为了保证类型安全性
	2. 比如
```java
DynamicArray<Integer> arr = new DynamicArray<>();
DynamicArray<? extends Number> nums = ints;
// 报错：不可写
nums.add(new Double(0.3));
// 报错：不可写
nums.add(new String("hello"));
```
3. 可借助泛型方法：很多内部类也是这么使用的
	1. 原因：对外用`<?>`通配符保证兼容性，对内用`<T>`保证类型安全性
```java
private static <T> void swapInternal(DynamicArray<T> arr, int i, int j)
// 对外公开
public static void swap(DynamicArray<?> arr, int i, int j)
```
## 2.3 超类型通配符
1. `<? super E>`，表示`E`的某个父类型
2. 适用于用父类的方法来完成子类的操作，比如通用的复制、比较等
## 2.4 通配符比较
1. `<? super E>`用于灵活写入或比较
2. `<? extends E>`用于灵活读取

# 3. 细节和局限性
## 3.2 使用泛型类、方法和接口
1. 不能使用基本数据类型
2. 不能创建泛型数组（防止赋值出现类型不一致的错误）
3. 为实现创建泛型数组的功能，可以使用反射机制`Class<Z>`